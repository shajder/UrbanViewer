#ifndef SHADERS_H
#define SHADERS_H 1

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

static char terrain_filter_vert[] =
"varying vec4 vcolor;                                                                       \n"
"varying vec4 ecp;                                                                          \n"
"varying vec3 normal;                                                                       \n"
"varying vec2 tcw;                                                                          \n"
"                                                                                           \n"
"uniform vec3 lightPos;                                                                     \n"
"uniform vec4 lightAmbient;                                                                 \n"
"uniform vec4 lightDiffuse;                                                                 \n"
"uniform mat4 osg_ViewMatrixInverse;                                                        \n"
"                                                                                           \n"
"vec4 vert_proc(in vec4 vert, in vec3 ecnor)                                                \n"
"{                                                                                          \n"
"  vec4 ambiCol = vec4(0.0);                                                                \n"
"  vec4 diffCol = vec4(0.0);                                                                \n"
"  float nDotVP    = max(0.0, dot(ecnor, lightPos));                                        \n"
"                                                                                           \n"
"  ambiCol  = lightAmbient;                                                                 \n"
"  diffCol  = lightDiffuse * nDotVP;                                                        \n"
"  vcolor = (ambiCol + diffCol);                                                            \n"
"                                                                                           \n"
"  normal = gl_Normal;                                                                      \n"
"  ecp = gl_ModelViewMatrix * vert;                                                         \n"
"  tcw = vert.xy * 0.001;                                                                   \n"
"  return vert;                                                                             \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

char tiled_terrain_color_filter_PSSM_frag[] =
#ifdef _ANDROID_
"precision mediump float;                                                                   \n"
"uniform highp vec3 lightPos;                                                               \n"
"uniform highp mat4 osg_ViewMatrix;                                                         \n"
"varying highp vec4 ecp;                                                                    \n"
"varying highp vec2 tcw;                                                                    \n"
#else
"uniform vec3 lightPos;                                                                     \n"
"uniform mat4 osg_ViewMatrix;                                                               \n"
"varying vec4 ecp;                                                                          \n"
"varying vec2 tcw;                                                                          \n"
#endif
"                                                                                           \n"
"varying vec3 normal;                                                                       \n"
"uniform sampler2D sampler1;                                                                \n"
"uniform sampler2D sampler2;                                                                \n"
"uniform sampler2D sampler3;                                                                \n"
"                                                                                           \n"
"uniform float FresnelApproxPowFactor;                                                      \n"
"uniform float DynamicRange1;                                                               \n"
"uniform float DynamicRange2;                                                               \n"
"uniform vec4 lightAmbient;                                                                 \n"
"const vec4 OceanLight = vec4(0.1, 0.2, 0.4, 1.0);                                          \n"
"const vec4 OceanDark = vec4(0.0, 0.1, 0.2, 1.0);                                           \n"
"                                                                                           \n"
"varying vec4 vcolor;                                                                       \n"
"                                                                                           \n"
"vec4 ColorFilter( in vec4 color )                                                          \n"
"{                                                                                          \n"
"	vec4 c0 = texture2D(sampler1, tcw*30.0) * vcolor;                                         \n"
"	vec4 c1 = texture2D(sampler2, tcw*20.0) * vcolor;                                         \n"
"	vec4 c2 = vec4(1.0);                                                                      \n"
"                                                                                           \n"
"  vec3 NH = texture2D(sampler3, tcw*0.5).xyz * vec3(2.0) - vec3(1.0);                      \n"
"  vec3 N = normal;                                                                         \n"
"  vec3 T = normalize(cross(vec3(0, 1, 0), N));                                             \n"
"                                                                                           \n"
"  mat3 vmo = mat3(osg_ViewMatrix[0].xyz, osg_ViewMatrix[1].xyz, osg_ViewMatrix[2].xyz);    \n"
"                                                                                           \n"
"  N = normalize(vmo * N);                                                                  \n"
"  T = normalize(vmo * T);                                                                  \n"
"  vec3 B = normalize(cross(N, T));                                                         \n"
"                                                                                           \n"
"  mat3 tbn = mat3(T, B, N);                                                                \n"
"  vec3 ecNorm = N;                                                                         \n"
"                                                                                           \n"
"  vec3 ecPosNorm = normalize(ecp.xyz);                                                     \n"
"  float NdotE = dot(N, -ecPosNorm);                                                        \n"
"                                                                                           \n"
"  N = tbn * NH;                                                                            \n"
"  N = mix( N, ecNorm, pow(abs(1.0-NdotE), 3.0));                                           \n"
"  vec3 L = lightPos;                                                                       \n"
"  vec3 specular = vec3(0.0);                                                               \n"
"  float nDotVP = max(0.0, dot(N, L));                                                      \n"
"                                                                                           \n"
"  if (nDotVP > 0.0)                                                                        \n"
"  {                                                                                        \n"
"    vec3 E = -ecPosNorm;                                                                   \n"
"    vec3 R = normalize(reflect(-L, N));                                                    \n"
"                                                                                           \n"
"    float specPow = 72.0;                                                                  \n"
"    float specScl = 0.4;                                                                   \n"
"    specular = vec3(pow(max(dot(R, E), 0.0), specPow) * specScl);                          \n"
"                                                                                           \n"
"    specular.rgb *= max(0.0, 1.0-pow(abs(1.0-NdotE), 8.0));                                \n"
"  }                                                                                        \n"
"  NdotE = dot(N, -ecPosNorm);                                                              \n"
"  float fres = pow(abs(1.0 + NdotE), -FresnelApproxPowFactor);                             \n"
"                                                                                           \n"
"  // setup dynamic range fresnel term                                                      \n"
"  fres *= DynamicRange1;                                                                   \n"
"                                                                                           \n"
"  float integralPart = floor(fres);                                                        \n"
"  float fractionPart = fract(fres);                                                        \n"
"                                                                                           \n"
"  vec4 color1;                                                                             \n"
"  vec4 color2;                                                                             \n"
"  color1.a = fractionPart; // fraction part                                                \n"
"  color2.a = integralPart * DynamicRange2;                                                 \n"
"                                                                                           \n"
"  color1.rgb = vec3(NdotE);                                                                \n"
"  vec4 resval = vec4((color2.a) + (color1.a * 0.5));                                       \n"
"  resval.rgb += mix(OceanLight.rgb, OceanDark.rgb, color1.rgb) + specular;                 \n"
"                                                                                           \n"
"  resval.a = 1.0;                                                                          \n"
"  c2 = resval;                                                                             \n"
"                                                                                           \n"
"  const float eps = 0.05;                                                                  \n"
"  float f0 = 0.0;                                                                          \n"
"  float f1 = 0.0;                                                                          \n"
"  float f2 = 0.0;                                                                          \n"
"  if ( (color.b - 0.0) < eps ) f0 = 1.0;                                                   \n"
"  else if ( (color.b - 0.5) < eps ) f1 = 1.0;                                              \n"
"  else if ( (color.b - 1.0) < eps ) f2 = 1.0;                                              \n"
"	 vec4 cult = c0*vec4(f0)+c1*vec4(f1)+c2*vec4(f2);                                         \n"
"                                                                                           \n"
"  float road_fade_fac = (sign(0.01 - color.r) - 1.0) * (-0.5);                             \n"
"  float road_fade_val = 0.2+0.8*(1.0 - pow(abs(1.0-color.r),4.0));                         \n"
"	 cult.rgb *= mix(vec3(1.0), vec3(road_fade_val), road_fade_fac);                          \n"
"	 vec4 ocol = cult;                                                                        \n"
"  return ocol;                                                                             \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

static char terrain_color_filter_PSSM_frag[] =
"uniform sampler2D sampler1;                                                                \n"
"uniform sampler2D sampler3;                                                                \n"
"uniform vec2 viewport;                                                                     \n"
"uniform vec4 lightAmbient;                                                                 \n"
"                                                                                           \n"
"varying float fade;                                                                        \n"
"varying vec4 vcolor;                                                                       \n"
"varying vec4 ecp;                                                                          \n"
"                                                                                           \n"
"vec4 ColorFilter( in vec4 color )                                                          \n"
"{                                                                                          \n"
"	   vec4 ocol = color * vcolor;                                                            \n"
"    return ocol;                                                                           \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

static char terrain_color_filter_vert[] =
"varying vec4 vcolor;                                                                       \n"
"varying vec4 ecp;                                                                          \n"
"                                                                                           \n"
"uniform vec3 lightPos;                                                                     \n"
"uniform vec4 lightAmbient;                                                                 \n"
"uniform vec4 lightDiffuse;                                                                 \n"
"                                                                                           \n"
"vec4 vert_proc(in vec4 vert, in vec3 ecnor)                                                \n"
"{                                                                                          \n"
"  vec4 ambiCol = vec4(0.0);                                                                \n"
"  vec4 diffCol = vec4(0.0);                                                                \n"
"  float nDotVP    = max(0.0, dot(ecnor, lightPos));                                        \n"
"                                                                                           \n"
"  ambiCol  = lightAmbient;                                                                 \n"
"  diffCol  = lightDiffuse * nDotVP;                                                        \n"
"  vcolor = (ambiCol + diffCol);                                                            \n"
"                                                                                           \n"
"  ecp = gl_ModelViewMatrix * vert;                                                         \n"
"  return vert;                                                                             \n"
"}                                                                                          \n";


////////////////////////////////////////////////////////////////////////////////

static char layered_shadow_cast_geom[] =
"#version 430 compatibility                                                                 \n"
"layout (triangles) in;                                                                     \n"
"layout(triangle_strip, max_vertices = 24) out;                                             \n"
"in vec4 ecPos[];                                                                           \n"
"                                                                                           \n"
"vec4 ppPos[3];                                                                             \n"
"                                                                                           \n"
"void main()                                                                                \n"
"{                                                                                          \n"
"  for (int j = 0; j < NUM_LAYERS; j++)                                                     \n"
"  {                                                                                        \n"
"    bool inRange=false;                                                                    \n"
"    for (int i = 0; i < 3; i++)                                                            \n"
"    {                                                                                      \n"
"      ppPos[i] = projMat[j] * ecPos[i];                                                    \n"
"      vec4 app = abs(ppPos[i]);                                                            \n"
"      if(app.x<1.0&&app.y<1.0&&app.z<1.0)                                                  \n"
"        inRange=true;                                                                      \n"
"    }                                                                                      \n"
"    if ( inRange==true)                                                                    \n"
"    {                                                                                      \n"
"      for (int i = 0; i < 3; i++)                                                          \n"
"      {                                                                                    \n"
"        gl_Layer = j;                                                                      \n"
"        gl_PrimitiveID = j;                                                                \n"
"        gl_Position = ppPos[i];                                                            \n"
"        EmitVertex();                                                                      \n"
"      }                                                                                    \n"
"      EndPrimitive();                                                                      \n"
"    }                                                                                      \n"
"  }                                                                                        \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

static char screen_vert[] =
"#version 420 compatibility\n"
"out vec2 tc;                                                                               \n"
"void main( )                                                                               \n"
"{                                                                                          \n"
"    gl_Position   = gl_ModelViewProjectionMatrix * gl_Vertex;                              \n"
"    tc = gl_MultiTexCoord0.xy;                                                             \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////
// shockwave

static char screen_frag[] =
"#version 420 compatibility                                                                 \n"
#ifdef _ANDROID_
"precision mediump float;                                                                   \n"
#endif                                                                                      
"uniform sampler2D sampler0;                                                                \n"
"uniform sampler2D sampler1;                                                                \n"
"                                                                                           \n"
"layout(location = 0, index = 0) out vec4 out_Color;                                        \n"
"layout(location = 1, index = 0) out float out_Depth;                                       \n"
"                                                                                           \n"
"varying vec2 tc;                                                                           \n"
"                                                                                           \n"
"void main (void)                                                                           \n"
"{                                                                                          \n"
"  vec4 color0 = texture2D(sampler0, tc);                                                   \n"
"  out_Color = color0;                                                                      \n"
"  out_Depth = texture2D(sampler1, tc).x;                                                   \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

static char screen_linearize_frag[] =
"#version 430 compatibility                                                                 \n"
#ifdef _ANDROID_
"precision mediump float;                                                                   \n"
#endif                                                                                                        
"uniform vec4 clipInfo;                                                                     \n"
"uniform sampler2D sampler0;                                                                \n"
"layout(location = 0, index = 0) out float out_Color;                                       \n"
"                                                                                           \n"
"float reconstructCSZ(float d, vec4 clipInfo) {                                             \n"
"    return ((clipInfo[0]*clipInfo[2]) / (clipInfo[1] * d + clipInfo[2]));                  \n"
"}                                                                                          \n"
"                                                                                           \n"
"void main() {                                                                              \n"
"  float depth = texelFetch(sampler0, ivec2(gl_FragCoord.xy), 0).x;                         \n"
"  out_Color = reconstructCSZ(depth, clipInfo);                                             \n"
"}                                                                                          \n";


////////////////////////////////////////////////////////////////////////////////

static char screen_HBAO_frag[] =
"#version 430 compatibility                                                                 \n"
#ifdef _ANDROID_
"precision mediump float;                                                                   \n"
#endif       
"#define HBAO_RANDOM_ELEMENTS 16                                                            \n"
"struct HBAOData                                                                            \n"
"{                                                                                          \n"
"  float             radToScreen;                                                           \n"
"  float             rad2;                                                                  \n"
"  float             negInvRad2;                                                            \n"
"  float             NDotVBias;                                                             \n"
"  vec2              invFullRes;                                                            \n"
"  vec2              invQuarterRes;                                                         \n"
"  float             AOMult;                                                                \n"
"  float             powExp;                                                                \n"
"  vec4              projInfo;                                                              \n"
"  vec2              jitters[HBAO_RANDOM_ELEMENTS];                                         \n"
"};                                                                                         \n"
"                                                                                           \n"
"layout(std140) uniform controlBuffer                                                       \n"
"{                                                                                          \n"
"    HBAOData control;                                                                      \n"
"};                                                                                         \n"
"#define M_PI 3.14159265f                                                                   \n"
"//----------------------------------------------------------------------------------       \n"
"// tweakables                                                                              \n"
"const float  NUM_STEPS = 4;                                                                \n"
"const float  NUM_DIRECTIONS = 8; // texRandom/g_Jitter initialization depends on this      \n"
"//----------------------------------------------------------------------------------       \n"
"layout(binding = 0) uniform sampler2D sampler0;                                            \n"
"//----------------------------------------------------------------------------------       \n"
"layout(location = 0, index = 0) out vec4 out_Color;                                        \n"
"in vec2 tc;                                                                                \n"
"//----------------------------------------------------------------------------------       \n"
"void outputColor(vec4 color) {                                                             \n"
"  out_Color = color;                                                                       \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"vec3 UVToView(vec2 uv, float eye_z)                                                        \n"
"{                                                                                          \n"
"  return vec3((uv*control.projInfo.xy+control.projInfo.zw)*eye_z, eye_z);                  \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"vec3 FetchViewPos(vec2 UV)                                                                 \n"
"{                                                                                          \n"
"  float ViewDepth = textureLod(sampler0, UV, 0).x;                                         \n"
"  return UVToView(UV, ViewDepth);                                                          \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"vec3 MinDiff(vec3 P, vec3 Pr, vec3 Pl)                                                     \n"
"{                                                                                          \n"
"  vec3 V1 = Pr - P;                                                                        \n"
"  vec3 V2 = P - Pl;                                                                        \n"
"  return (dot(V1, V1) < dot(V2, V2)) ? V1 : V2;                                            \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"vec3 ReconstructNormal(vec2 UV, vec3 P)                                                    \n"
"{                                                                                          \n"
"  vec3 Pr = FetchViewPos(UV + vec2(control.invFullRes.x, 0));                              \n"
"  vec3 Pl = FetchViewPos(UV + vec2(-control.invFullRes.x, 0));                             \n"
"  vec3 Pt = FetchViewPos(UV + vec2(0, control.invFullRes.y));                              \n"
"  vec3 Pb = FetchViewPos(UV + vec2(0, -control.invFullRes.y));                             \n"
"  return normalize(cross(MinDiff(P, Pr, Pl), MinDiff(P, Pt, Pb)));                         \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"float Falloff(float DistanceSquare)                                                        \n"
"{                                                                                          \n"
"  // 1 scalar mad instruction                                                              \n"
"  return DistanceSquare * control.negInvRad2 + 1.0;                                        \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"// P = view-space position at the kernel center                                            \n"
"// N = view-space normal at the kernel center                                              \n"
"// S = view-space position of the current sample                                           \n"
"//----------------------------------------------------------------------------------       \n"
"float ComputeAO(vec3 P, vec3 N, vec3 S)                                                    \n"
"{                                                                                          \n"
"  vec3 V = S - P;                                                                          \n"
"  float VdotV = dot(V, V);                                                                 \n"
"  float NdotV = dot(N, V) * 1.0 / sqrt(VdotV);                                             \n"
"  // Use saturate(x) instead of max(x,0.f) because that is faster on Kepler                \n"
"  return clamp(NdotV - control.NDotVBias, 0, 1) * clamp(Falloff(VdotV), 0, 1);             \n"
"}                                                                                          \n"
"//----------------------------------------------------------------------------------       \n"
"float ComputeCoarseAO(vec2 FullResUV, float RadPix, vec2 Rand, vec3 ViewPos, vec3 ViewNor) \n"
"{                                                                                          \n"
"  // Divide by NUM_STEPS+1 so that the farthest samples are not fully attenuated           \n"
"  float StepSizePixels = RadPix / (NUM_STEPS + 1);                                         \n"
"  const float Alpha = 2.0 * M_PI / NUM_DIRECTIONS;                                         \n"
"  float AO = 0;                                                                            \n"
"  for (float DirectionIndex = 0; DirectionIndex < NUM_DIRECTIONS; ++DirectionIndex)        \n"
"  {                                                                                        \n"
"    float Angle = Alpha * DirectionIndex+ Rand.x;                                          \n"
"    // Compute normalized 2D direction                                                     \n"
"    vec2 Direction = vec2(cos(Angle), sin(Angle));                                         \n"
"    // Jitter starting sample within the first step                                        \n"
"    float RayPixels = (Rand.y * StepSizePixels + 1.0);                                     \n"
"    for (float StepIndex = 0; StepIndex < NUM_STEPS; ++StepIndex)                          \n"
"    {                                                                                      \n"
"      vec2 SnappedUV = round(RayPixels * Direction) * control.invFullRes  + FullResUV;     \n"
"      vec3 S = FetchViewPos(SnappedUV);                                                    \n"
"      RayPixels += StepSizePixels;                                                         \n"
"      AO += ComputeAO(ViewPos, ViewNor, S);                                                \n"
"    }                                                                                      \n"
"  }                                                                                        \n"
"  AO *= control.AOMult / (NUM_DIRECTIONS * NUM_STEPS);                                     \n"
"  return clamp(1.0 - AO * 2.0, 0, 1);                                                      \n"
"}                                                                                          \n"
"                                                                                           \n"
"//----------------------------------------------------------------------------------       \n"
"void main()                                                                                \n"
"{                                                                                          \n"
"  vec2 uv = tc;                                                                            \n"
"  vec3 ViewPos = FetchViewPos(uv);                                                         \n"
"  vec3 ViewNor = -ReconstructNormal(uv, ViewPos);                                          \n"
"  // Compute projection of disk of radius control.R into screen space                      \n"
"  float RadPix = (control.radToScreen / ViewPos.z);                                        \n"
"  // Get jitter vector for the current full-res pixel                                      \n"
"                                                                                           \n"
"  ivec2 RandInd = ivec2(gl_FragCoord.xy) % ivec2(4.0);                                     \n"
"  vec2 Rand = control.jitters[RandInd.y * 4 + RandInd.x];                                  \n"
"                                                                                           \n"
"  float AO = ComputeCoarseAO(uv, RadPix, Rand, ViewPos, ViewNor);                          \n"
"  outputColor(vec4(pow(AO, control.powExp)));                                              \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

static char screen_apply_SSAO_frag[] =
"#version 430 compatibility                                                                 \n"
#ifdef _ANDROID_                                                                            
"precision mediump float;                                                                   \n"
#endif                                                                                      
"in vec2 tc;                                                                                \n"
"uniform sampler2D sampler0;                                                                \n"
"layout(location=0,index=0) out vec4 out_Color;                                             \n"
"                                                                                           \n"
"void main (void)                                                                           \n"
"{                                                                                          \n"
"   out_Color = vec4(texture(sampler0, tc).x);                                              \n"
"}                                                                                          \n";

////////////////////////////////////////////////////////////////////////////////

#endif
